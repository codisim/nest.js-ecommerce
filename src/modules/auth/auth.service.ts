import { ConflictException, Injectable, InternalServerErrorException, UnauthorizedException } from '@nestjs/common';
import { PrismaService } from 'src/prisma/prisma.service';
import { RegisterDto } from './dto/register.dto';
import { AuthResponseDto } from './dto/auth-response.dto';
import * as bcrypt from 'bcrypt';
import { JwtService } from '@nestjs/jwt';
import { randomBytes } from 'crypto';
import { ConfigService } from '@nestjs/config';
import { LoginDto } from './dto/login.dto';

@Injectable()
export class AuthService {
    private readonly SALT_ROUNDS = 12;
    constructor(
        private prisma: PrismaService,
        private jwtService: JwtService,
        private configService: ConfigService,
    ) { }

    async register(registerDto: RegisterDto): Promise<AuthResponseDto> {
        const { email, password, firstName, lastName } = registerDto;

        const existingUser = this.prisma.user.findUnique({
            where: {
                email
            }
        })

        if (existingUser)
            throw new ConflictException('User already exists')

        try {
            const hashedPassword = await bcrypt.hash(password, this.SALT_ROUNDS);

            const user = await this.prisma.user.create({
                data: {
                    email,
                    password: hashedPassword,
                    firstName,
                    lastName
                },
                select: {
                    id: true,
                    email: true,
                    firstName: true,
                    lastName: true,
                    role: true,
                    password: false
                }
            })

            const tokens = await this.generateTokens(user.id, user.email);

            await this.updateRefreshToken(user.id, tokens.refreshToken);

            return {
                ...tokens,
                user
            }

        } catch (error) {
            console.error('Error during user registration: ', error);
            throw new InternalServerErrorException('Internal server error in registration');
        }
    }


    // generate access and refresh token
    private async generateTokens(
        userId: string,
        email: string
    ): Promise<{ accessToken: string, refreshToken: string }> {

        const payload = {
            sub: userId,
            email
        };
        const refreshId = randomBytes(32).toString('hex');

        const [accessToken, refreshToken] = await Promise.all([
            this.jwtService.signAsync(payload, { expiresin: '15m' }),
            this.jwtService.signAsync({ ...payload, refreshId }, { expiresin: '7d' })
        ])

        return [accessToken, refreshToken];

    }



    // update refresh token in db
    async updateRefreshToken(userId: string, refreshToken: string): Promise<void> {
        await this.prisma.user.update({
            where: { id: userId },
            data: { refreshToken }
        });
    }


    // refresh access token
    async refreshTokens(userId: string): Promise<AuthResponseDto> {
        const user = await this.prisma.user.findUnique({
            where: { id: userId },
            select: {
                id: true,
                email: true,
                firstName: true,
                lastName: true,
                role: true
            }
        });

        if (!user)
            throw new InternalServerErrorException('User not found');

        const tokens = await this.generateTokens(user.id, user.email);
        await this.updateRefreshToken(user.id, tokens.refreshToken);

        return {
            ...tokens,
            user
        }

    }


    async logout(userId: string): Promise<void> {
        await this.prisma.user.update({
            where: { id: userId },
            data: { refreshToken: null }
        })
    }


    async login(loginDto: LoginDto): Promise<AuthResponseDto> {
        const user = await this.prisma.user.findUnique({
            where: { email: loginDto.email }
        });

        if (!user || !await bcrypt.compare(loginDto.password, user.password))
            throw new UnauthorizedException('Invalid credentials');

        const tokens = await this.generateTokens(user.id, user.email);
        await this.updateRefreshToken(user.id, tokens.refreshToken);

        return {
            ...tokens,
            user: {
                id: user.id,
                email: user.email,
                firstName: user.firstName,
                lastName: user.lastName,
                role: user.role
            }
        }

    }

}
